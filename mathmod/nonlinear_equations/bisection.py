from typing import Callable


def bisection(
    f: Callable, 
    a: float, 
    b: float, 
    epsilon=1e-6
) -> tuple[float, int]:
    """
    Метод бисекций для нахождения корня функции на интервале [a, b].
    
    :param f: Функция, корень которой нужно найти. Функция должна быть продолжительной на интервале [a, b] и иметь разные знаки на концах интервала.
    :param a: Левый конец интервала.
    :param b: Правый конец интервала.
    :param epsilon: Точность, при которой метод останавливается, когда длина интервала становится меньше epsilon. По умолчанию 1e-6.
    
    :return: Кортеж из двух значений: корень уравнения и количество итераций, выполненных для нахождения решения.
    
    :raises ValueError: Если на концах интервала значения функции имеют одинаковый знак (f(a) * f(b) >= 0).
    """

    if f(a) * f(b) >= 0:
        raise ValueError("Указан неверный участок локализации! f(a) * f(b) должно быть отрицательным.")
    
    i = 0
    c = a

    while (b - a) > 2 * epsilon:
        c = (a + b) / 2  
        if f(c) == 0:  
            break
        elif f(c) * f(a) < 0:  
            b = c
        else:  
            a = c
        i += 1
    
    return c, i


