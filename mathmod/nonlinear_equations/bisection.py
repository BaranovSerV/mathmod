from typing import Callable


def bisection(
    f: Callable, 
    a: float, 
    b: float, 
    epsilon=1e-6
) -> tuple[float, int]:
    """
    Метод бисекций для нахождения корня нелинейного уравнения.

    :param f: Функция, корень которой нужно найти. 
        Функция должна быть продолжительной на интервале [a, b] и иметь разные знаки на концах интервала.
    :param a: Левый конец интервала.
    :param b: Правый конец интервала.
    :param epsilon: Точность, при которой метод останавливается, 
        когда длина интервала становится меньше epsilon. По умолчанию 1e-6.

    :return: Приближённое значение корня и количество итераций.
    """

    if f(a) * f(b) >= 0:
        raise ValueError(
            "Указан неверный участок локализации! f(a) * f(b) должно быть отрицательным"
        )
    
    i = 0
    c = a

    while (b - a) > 2 * epsilon:
        c = (a + b) / 2  
        if f(c) == 0:  
            break
        elif f(c) * f(a) < 0:  
            b = c
        else:  
            a = c
        i += 1
    
    return c, i


